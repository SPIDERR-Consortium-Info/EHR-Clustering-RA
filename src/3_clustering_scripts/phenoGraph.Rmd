---
title: "iClusterBayesian"
author: "Tjardo M"
date: "4/1/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
# Set working directory
setwd('/exports/reum/tdmaarseveen/RA_Clustering')

# Set library folder
.libPaths("/exports/reum/tdmaarseveen/Rlibs")

```



## Import datasets

```{r}
library("readr")


dt <- as.matrix(read_csv("../../data/6_clustering/INDIVIDUAL_mannequin_categorical_ohe.csv"))
# df_numerical_normalized.csv
#df_a <- as.matrix(read_csv("../../data/6_clustering/INDIVIDUAL_mannequin_categorical_ohe.csv")) # , 
# df_b <- as.matrix(read_csv("../../data/6_clustering/df_tfidf.csv"))
#df_c <- as.matrix(read_csv("../../data/6_clustering/INDIVIDUAL_mannequin_counts_normalized_scaling.csv"))
#df_d <- as.matrix(read_csv("../../data/6_clustering/df_lab_serology.csv"))
#df_e <- as.matrix(read_csv("../../data/6_clustering/df_lab_numerical.csv"))

```


```{r}
#install.packages("tidyverse")
library("readr")


# df_numerical_normalized.csv
df_cat <- as.matrix(read_csv("../../data/6_clustering/df_categorical_ohe.csv")) # , col_types= cols(.default = col_logical())
#df_counts <- as.matrix(read_csv("../../data/6_clustering/df_counts.csv"))
#df_con <- as.matrix(read_csv("../../data/6_clustering/df_continuous.csv"))
df_num <- as.matrix(read_csv("../../data/6_clustering/df_numerical_normalized.csv"))
#head(df_cat)
```
## Install Bioconductor Manager and iClusterPlus
```{r}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("MOFA2")
```


## Install Bioconductor Manager and iClusterPlus
```{r}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("iClusterPlus")
```



```{r}
library(iClusterPlus)
# "poisson"
fit <- iClusterBayes(dt1=df_cat, dt2=df_num,
	type = c("binomial","gaussian"),K=2,n.burnin=18000,n.draw=12000,
	prior.gamma=rep(0.1,6),sdev=0.5,beta.var.scale=1,thin=1,pp.cutoff=0.5) # more iterations
```

```{r}
write.csv(fit$clusters,"../../data/6_clustering/df_embedding_iCluster_clusters.csv", row.names = FALSE)

write.csv(fit$meanZ,"../../data/6_clustering/df_embedding_iCluster.csv", row.names = FALSE)
```


# CNregions - remove redunant features
# Optimize Bayesian
```{r}
library(iClusterPlus)
bayfit = tune.iClusterBayes(cpus=10, dt1=df_cat, dt2=df_num, n.burnin=1000,n.draw=1200,  type=c("binomial","gaussian"),K=1:15, prior.gamma=c(0.5,0.5),sdev=0.05,thin=3) #  n.burnin=18000, n.draw=12000,

```
# How many K?

```{r}
allBIC = NULL
devratio = NULL
nK = length(bayfit$fit)
# nK
for(i in 1:nK){
  allBIC = c(allBIC,bayfit$fit[[i]]$BIC)
  devratio = c(devratio,bayfit$fit[[i]]$dev.ratio)
}

par(mar=c(4.0,4.0,0.5,0.5),mfrow=c(1,2))
plot(1:nK, allBIC,type="b",xlab="k",ylab="BIC",pch=c(1,1,1,1,1,19,1,1,1,1,1,1))
plot(1:nK,devratio,type="b",xlab="k",ylab="Deviance ratio",pch=c(1,1,1,1,1,19,1,1,1,1,1,1))
```

```{r}

best.cluster.Bayes = bayfit$fit[[2]]$clusters
#best.cluster is the clusters generated by iClusterPlus; See the above code
table(best.cluster,best.cluster.Bayes)
```



```{r}
library(gplots)
library(lattice)
bw.col = colorpanel(2,low="white",high="black")
col.scheme = alist()
col.scheme[[1]] = bw.col
col.scheme[[2]] = bluered(256)
#col.scheme[[3]] = bluered(256)
plotHeatmap(fit=fit,datasets=list(df_cat,df_num),
type=c("binomial","gaussian"), col.scheme = col.scheme,
row.order=c(T,F),sparse=c(F,F),cap=c(F,F))
# ,chr=chr,plot.chr=c(F,T),sparse=c(T,F),cap=c(F,T)
```

```{r}
features = alist()
features[[1]] = colnames(df_cat)
features[[2]] = colnames(df_num)
sigfeatures=alist()
for(i in 1:2){
  rowsum=apply(abs(fit$beta[[i]]),1, sum)
  upper=quantile(rowsum,prob=0.75)
  sigfeatures[[i]]=(features[[i]])[which(rowsum>upper)]
  }
names(sigfeatures)=c("cat","num") # ,"expression"
#print a few examples of selected features
head(sigfeatures[[1]])
```


```{r}
sigfeatures[[2]]
#rowsum
```


## Import complete data

```{r}
library(readr)

df_cluster <- read_csv("../../data/4_imputed/DF_Lab_imputed.csv", col_types = cols(X1 = col_skip()))
head(df_cluster)
```
## Create matrix
Use Gower distance (https://towardsdatascience.com/clustering-datasets-having-both-numerical-and-categorical-variables-ed91cdca0677)

```{r}
pat <- as.factor(df_cluster$patnr)
#df_cluster = subset(df_cluster, select = -c(time, patnr))
```



```{r}
library(cluster)
m <- daisy(subset(df_cluster, select = -c(time, patnr)),
                    metric = "gower" ,
                    type = list(logratio = 11)) # 11 = BSE
m <- as.matrix(m)
rownames(m) <- pat
colnames(m) <- pat
# rownames(m) <- pat
# colnames(m) <- pat
```


## Rphenograph
```{r}
#Phenograph
dat_graph <- Rphenograph(m)

save(dat_graph, file = "../../data/6_phenograph/dat_graph.RData")

graph_key <- cbind(rownames(m)[as.numeric(dat_graph[[2]]$name)], dat_graph[[2]]$membership)

save(graph_key, file = "../../data/6_phenograph/graph_key.RData")

```


## Clustering Data
```{r}
#Clustering data
dat_clust <- merge(df_cluster, graph_key, by.x = "patnr", by.y = 1, all.x = T)

colnames(dat_clust)[ncol(dat_clust)] <- "Cluster"

save(dat_clust, file = "../../data/6_phenograph/dat_clust.RData")

```


## Embedding - TSNE
```{r}
library(Rtsne)

#Embedding
dat_tsne <- Rtsne(m, dims = 2, perplexity = 30, verbose = F, max_iter = 5000, check_duplicates = F, pca = F, num_threads = 0) # dat_harm 

rownames(dat_tsne$Y) <- rownames(m)

save(dat_tsne, file = "../../data/6_phenograph/dat_tsne.RData")
```

## Embedding - UMAP
```{r}
library(umap)
dat_umap <- umap(m) # dat_harm

save(dat_umap, file = "../../data/6_phenograph/dat_umap.RData")
```

#Visualise T-SNE

```{r}
head(plot_tsne)
```


```{r}
library(RColorBrewer)
colourset <- colors(distinct = T)
colourset <- colourset[-grep("gray|white", colourset)]

my_pch ="."

plot_tsne <- data.frame(X = dat_tsne$Y[,1],
                        Y = dat_tsne$Y[,2],
                        ID = rownames(dat_tsne$Y)) 

plot_tsne <- merge(plot_tsne, graph_key, by.x = "ID", by.y = 1)
colnames(plot_tsne)[ncol(plot_tsne)] <- "Cluster"

plot_tsne <- merge(plot_tsne, df_cluster, by.x = "ID", by.y = "patnr")

plot_tsne$Cluster <- as.factor(plot_tsne$Cluster)

# UMAP
plot_umap <- data.frame(X = dat_umap$layout[,1],
                        Y = dat_umap$layout[,2],
                        ID = rownames(dat_umap$layout))

plot_umap <- merge(plot_umap, graph_key, by.x = "ID", by.y = 1)
colnames(plot_umap)[ncol(plot_umap)] <- "Cluster"

plot_umap <- merge(plot_umap, df_cluster, by.x = "ID", by.y = "patnr")

plot_umap$Cluster <- as.factor(plot_umap$Cluster)

pdf(file = "embedding_plots.pdf")

```


## Ggplot
```{r}
library(ggplot2)
#  install.packages("viridis")
library(viridis)

#TSNE
plot_tsne <- plot_tsne[sample.int(nrow(plot_tsne)),]


ggplot(plot_tsne, aes(x = X, y = Y, colour = Cluster)) +
  geom_point(pch = my_pch,
             size = 2) +
  theme_classic() +
  scale_colour_manual(values = colourset) +
  theme(legend.position = "none") +
  labs(title = "tSNE embedding",
       subtitle = paste0("Showing kNN clustering (N = ", length(unique(plot_tsne$Cluster)), ")"),
       x = "",
       y = "") # PAM clustering
ggsave("../../figures/3_clustering/plot_tsne.pdf")

#UMAP
plot_umap <- plot_umap[sample.int(nrow(plot_umap)),]

ggplot(plot_umap, aes(x = X, y = Y, colour = Cluster)) +
  geom_point(pch = my_pch,
             size = 2) +
  theme_classic() +
  scale_colour_manual(values = colourset) +
  theme(legend.position = "none") +
  labs(title = "Umap embedding",
       subtitle = paste0("Showing kNN clustering (N = ", length(unique(plot_umap$Cluster)), ")"),
       x = "",
       y = "")
ggsave("../../figures/3_clustering/plot_umap.pdf")
dev.off()


```

```{r}
head(dat_clust)

#dat$Set
```


```{r}
head(data_long)
```

## PheSpec ??
```{r}
#Read function
source("Functions.R")

#Read code mapping file which contains colums "PheCode" "ICD" "Phenotype" "Category"
#phecodes_complete <- read.csv("../../data/6_phenograph/dat_clust.RData")
phecodes_complete <- data_long

#Read clustered data which contains colums "ID" "PheCode"
dat <- get(load("../../data/6_phenograph/dat_clust.RData"))

# EASY FIXX: add SET
id_set_match <- data.frame(ID = unique(dat$patnr), 
                           Set = sample(2, size = nrow(dat), replace = TRUE))

save(id_set_match, file = "../../data/6_phenograph/id_set_match.RData")
#Load ID dataset matching dataframe which contains colums "ID" "Set"
#load("id_set_match.RData")


library(tidyr)

data_long <- gather(dat, Phenotype, PheCode, MCV:RF, factor_key=TRUE)
dat <- data_long

#Make sure PheCode and Cluster are factors so each cluster has all codes measured (even at 0)
dat$PheCode <- as.factor(dat$PheCode)
dat$Cluster <- as.factor(dat$Cluster)
```

```{r}
#names(dat)[names(dat) == "pat"] <- "ID"
colnames(dat)[1] <- "ID"
head(dat)
```


```{r}
dat_uc <- unique(dat[,c("ID","Cluster", "PheCode")])
#Create list of expression vectors if it doesn't exist yet (in this case separate per dataset, so list of lists of vectors)
if(file.exists("../../data/6_phenograph/dat_em.RData")){
 load("../../data/6_phenograph/dat_em.RData")
} else {
  dat_em <- lapply(unique(id_set_match$Set), function(x){
    lapply(unique(dat$Cluster), function(y){
      tmp <- dat_uc[dat_uc$Cluster == y,]
      tmp <- tmp[tmp$ID %in% id_set_match[id_set_match$Set == x, "ID"],]
      table(tmp$PheCode)/length(unique(tmp$ID))
    })
  })
  names(dat_em) <- unique(id_set_match$Set)
  invisible(lapply(1:length(dat_em), function(x){
    names(dat_em[[x]]) <<- unique(dat$Cluster) 
  })
  )
  save(dat_em, file = "../../data/6_phenograph/dat_em.RData")
}
```

```{r}
#head(dat_em)
```


```{r}

# MAYBE ADD A DUMMY CATEGORY???

createPheSpec_multi <- function(N=1, Clusters, Dat, EM, Sets){
#Create consistent palette of colours mapped to categories
  col_rb <- c(rainbow(length(unique(phecodes_complete$Category))), "grey")
  names(col_rb) <- c(unique(as.character(phecodes_complete$Category)), "Unknown")

#Print legend once
  plot.new()
  legend(0.3,1, 
         legend = c(levels(factor(phecodes_complete$Category, 
                                levels = unique(phecodes_complete$Category))),
                    "Unknown"), 
         col = col_rb, 
         lty = 1,
         lwd = 2, 
         cex = 1)
         
  col_sets <- rainbow(length(unique(Sets$Set)))
  names(col_sets) <- unique(Sets$Set)
  names(col_sets) <- names(col_sets)[order(names(col_sets), decreasing = T)]
  print(' yes ' )
#Set some text size variables for the matrix later on
  mytheme <- gridExtra::ttheme_default(
    core = list(fg_params=list(cex = 0.6)),
    colhead = list(fg_params=list(cex = 0.6)),
    rowhead = list(fg_params=list(cex = 0.6)))

#Per cluster create a page in the pdf	
  invisible({
    lapply(1:min(c(N, length(Clusters))), function(x){
#Print which one we're at (mostly for debugging purposes)
    print(paste0("Creating PheSpec for Cluster ", Clusters[x]))
#Take the relevant subset of the data
    Sub <- Dat[Dat$Cluster == as.character(Clusters[x]),]
    Sub <- Sub[!duplicated(Sub$ID),]
    
#Determine the top contributing dataset based on size    
    Size <- nrow(Sub)
    
    Sizes <- table(Sets[Sets$ID %in% Sub$ID, "Set"])
    TopSet <- names(Sizes[order(Sizes, decreasing = T)])[1]

#For the top dataset extract the expression vector for this cluster	
    PlotDF <- data.frame(EM[[TopSet]][[as.character(Clusters[x])]])
#Merge with the PheCode mapping
    
    PlotDF <- merge(PlotDF, phecodes_complete[!duplicated(phecodes_complete$PheCode),c("PheCode", "Phenotype")], by.x = 1, by.y = "PheCode", all.x = T) # Category
    print(colnames(PlotDF))
    colnames(PlotDF) <- c("Code", "Freq") #, "Label", "Cat"
    print(paste0("Creating PheSpec1 for Cluster ", Clusters[x]))
#Add an "Unknown" label instead of NA to prevent ggplot from dropping them
    PlotDF$Code <- as.character(PlotDF$Code)
    #PlotDF$Cat <- NA # as.character(PlotDF$Cat) 
    #PlotDF[is.na(PlotDF$Cat), "Cat"] <- "Unknown"
	PlotDF$Label <- as.character(PlotDF$Label)
	print(paste0("Creating PheSpec2 for Cluster ", Clusters[x]))
#Order the data on category and code in the same order as the legend, then fix them as factors to make ggplot follow the order
    PlotDF <- PlotDF[order(match(PlotDF$Cat, c(unique(as.character(phecodes_complete$Category)), "Unknown")), PlotDF$Code),]
    PlotDF$Cat <- factor(PlotDF$Cat, levels = c(unique(as.character(phecodes_complete$Category)), "Unknown"))
    PlotDF$Code <- factor(PlotDF$Code, levels = unique(PlotDF$Code))   
  print(paste0("Creating PheSpec3 for Cluster ", Clusters[x]))
#Create top 10 most frequent codes table    
    Mat <- PlotDF[order(PlotDF$Freq, decreasing = T), c("Code", "Freq", "Label")][1:10,]
    Mat <- Mat[,c("Code", "Freq", "Label")]
    Mat$Freq <- round(as.numeric(Mat$Freq), digits = 2)
    print(paste0("Creating PheSpec for Cluster ", Clusters[x]))
#Abbreviate strings above 43 characters
    Mat$Label <- ifelse(nchar(Mat$Label) > 43, paste0(substring(Mat$Label, 1, 40), "..."), Mat$Label)
#Turn table into a grob
    m1 <- tableGrob(Mat, rows = NULL, theme = mytheme)

#Extract just the top 500 most frequent codes    
    included_codes <- PlotDF
    included_codes <- included_codes[order(included_codes$Freq, decreasing = T),]
    included_codes <- included_codes[1:500, "Code"]
    
    PlotDF <- PlotDF[PlotDF$Code %in% included_codes,]

#Extract the expression vector of this cluster for all sets    
    RestSets <- sapply(EM, `[`, as.character(Clusters[x]))
    names(RestSets) <- gsub("\\..*", "", names(RestSets))
#Calculate the correlation between the top set and all sets
    Cors <- sapply(1:length(RestSets), function(y){
      cor(RestSets[[TopSet]], RestSets[[y]])
    })
    names(Cors) <- names(RestSets)
	
#Create table containing size and correlation of each set
    SetMat <- data.frame(Size = as.vector(Sizes[names(RestSets)]),
                         Cor = round(Cors, 2),
                         Set = names(RestSets))
    SetMat <- SetMat[order(SetMat$Set),]
#Turn table into a grob
    m2 <- tableGrob(SetMat, rows = NULL, theme = mytheme)

#Create a dataframe for the miniatures the same way as done above (but smaller)    
    SetPlot <- melt(do.call("rbind", RestSets))
    colnames(SetPlot) <- c("Set", "Code", "Freq")
    SetPlot <- SetPlot[SetPlot$Code %in% included_codes,]
    SetPlot <- SetPlot[order(match(SetPlot$Code, levels(PlotDF$Code))),]
    SetPlot$Code <- factor(SetPlot$Code, levels = unique(SetPlot$Code))
    SetPlot <- SetPlot[order(as.character(SetPlot$Set), decreasing = F),]
    SetPlot$Set <- factor(SetPlot$Set, levels = unique(SetPlot$Set))

#Create main PheSpec	
	  p1 <- ggplot(PlotDF, aes(x = Code, y = Freq, fill = Cat, label = Label)) +
		geom_bar(stat = "identity") +
		scale_fill_manual(values = col_rb) +
		theme_classic() +
		theme(axis.ticks.x = element_blank(),
			  axis.text.x = element_blank(),
			  legend.position = "none") +
		scale_y_continuous(expand = c(0,0),
                       limits = c(0,1.2)) +
		labs(title = paste0(TopSet, " Cluster ", Clusters[x]),
			 subtitle = paste0("N = ", Size),
			 x = "PheCode",
			 y = "Frequency") +
		geom_label_repel(data = subset(PlotDF, Freq >= sort(PlotDF$Freq, decreasing = T)[3]),
                     segment.size  = 0.2,
                     segment.color = "grey50",
                     segment.alpha = 0.5,
                     nudge_y = 0.2,
                     direction = "y",
                     size = 5)

#Create miniatures					 
    p2 <- ggplot(SetPlot, aes(x = Code, y = Freq, fill = Set)) +
    geom_bar(stat = "identity") +
    facet_wrap(~Set) +
    scale_fill_manual(values = col_sets) +
    theme_classic() +
    theme(axis.ticks.x = element_blank(),
          axis.text.x = element_blank(),
          legend.position = "none") +
    scale_y_continuous(expand = c(0,0),
                       limits = c(0,1.2)) +
    labs(title = paste0("Remaining Datasets Cluster ", Clusters[x]),
         x = "PheCode",
         y = "Frequency")

#Arrange the 2 graphs and 2 tables unto 1 page with a bit of padding in the middle		 
	  grid.arrange(p1, grid.rect(gp=gpar(col="white")), m1,
                 p2, grid.rect(gp=gpar(col="white")), m2,
                 nrow = 2, ncol = 3,
                 widths = c(2,0.05,0.9))
    })
  })
}


```

```{r}
#head(dat_em)
```


```{r}
#Set pdf width to something a bit wider than normal to accommodate the entire plot and table nicely
pdf(file = paste0("../../figures/3_clustering/", format(Sys.Date(), "%Y%m%d"), "_phespecs.pdf"), width = 10)
invisible(createPheSpec_multi(N = length(levels(dat$Cluster)), Clusters = levels(dat$Cluster), Dat = dat, EM = dat_em, Sets = id_set_match))
dev.off()
```


## Download & install phenograph
Source = github.com/JinmiaoChenLab/Rphenograph 

```{r cars}
if(!require(devtools)){
  install.packages("devtools") # If not already installed
}
devtools::install_github("JinmiaoChenLab/Rphenograph")
```


## Perform phenograph on IRIS data

```{r pressure, echo=FALSE}
library(Rphenograph)
iris_unique <- unique(iris) # Remove duplicates
data <- as.matrix(iris_unique[,1:4])
Rphenograph_out <- Rphenograph(data, k = 45)
modularity(Rphenograph_out[[2]])
membership(Rphenograph_out[[2]])
iris_unique$phenograph_cluster <- factor(membership(Rphenograph_out[[2]]))
ggplot(iris_unique, aes(x=Sepal.Length, y=Sepal.Width, col=Species, shape=phenograph_cluster)) + geom_point(size = 3)+theme_bw()
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.


